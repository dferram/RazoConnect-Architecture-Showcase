# Multi-Tenancy Architecture

> **CÃ³mo una sola aplicaciÃ³n sirve a mÃºltiples clientes de forma completamente aislada**

---

## Â¿QuÃ© es Multi-Tenancy?

Multi-tenancy es una arquitectura donde una Ãºnica instancia de una aplicaciÃ³n sirve a mÃºltiples clientes (tenants), con cada tenant creyendo que tiene su propia aplicaciÃ³n privada.

### AnalogÃ­a: El Edificio de Apartamentos

Imagina un edificio con 3 apartamentos:
- Apartamento A (Razo)
- Apartamento B (Fashion)
- Apartamento C (TechPro)

Todos comparten:
- Mismo edificio (servidor)
- Misma red elÃ©ctrica (infraestructura)
- Mismo agua (base de datos)

Pero tienen:
- Apartamentos separados (datos aislados)
- Puertas con cerraduras diferentes (credenciales)
- Buzones privados (emails)

**Multi-tenancy = Un edificio eficiente, mÃºltiples apartamentos privados**

---

## Niveles de Aislamiento

### Nivel 1: Database Segregation (Raro en SaaS moderno)

**Idea:** Cada tenant tiene su propia base de datos

```
Razo        â†’ PostgreSQL DB 1
Fashion     â†’ PostgreSQL DB 2
TechPro     â†’ PostgreSQL DB 3
```

**Ventajas:**
- Aislamiento perfecto
- Escalabilidad independiente por tenant

**Desventajas:**
- Triple costo de infraestructura
- Triple mantenimiento (3 bases de datos)
- Complejidad de migrations (3x)
- Imposible agregar features a todos rÃ¡pido

---

### Nivel 2: Schema Segregation (Algunos usan esto)

**Idea:** Misma base de datos, pero esquemas separados

```
PostgreSQL DB
â”œâ”€â”€ Schema "razo_tenant"
â”œâ”€â”€ Schema "fashion_tenant"
â””â”€â”€ Schema "techpro_tenant"
```

**Ventajas:**
- Mejor que DB separadas
- Un PostgreSQL = costos menores

**Desventajas:**
- AÃºn requiere migrations en mÃºltiples esquemas
- Complejidad en queries (necesita conocer el esquema)
- DifÃ­cil manejar cambios de schema

---

### Nivel 3: Row-Level Isolation (La que usa RazoConnect)

**Idea:** Misma base de datos, mismos esquemas, pero cada fila tiene un tenant_id

```
PostgreSQL DB
â”œâ”€â”€ Tabla "productos"
â”‚   â”œâ”€â”€ productoid=1, tenant_id=1 (Razo)
â”‚   â”œâ”€â”€ productoid=2, tenant_id=2 (Fashion)
â”‚   â””â”€â”€ productoid=3, tenant_id=1 (Razo)
â””â”€â”€ Tabla "clientes"
    â”œâ”€â”€ clienteid=1, tenant_id=1
    â”œâ”€â”€ clienteid=2, tenant_id=2
    â””â”€â”€ ...
```

**Ventajas:**
- MÃ¡xima eficiencia operativa
- Una BD, un esquema, un codebase
- Features escalan a todos automÃ¡ticamente
- Costos mÃ­nimos

**Desventajas:**
- Requiere disciplina: cada query debe filtrar por tenant_id
- Si olvidas el filtro, Â¡datos privados se ven!

**RazoConnect eligiÃ³ esto porque el ROI es exponencial.**

---

## Â¿CÃ³mo se garantiza el aislamiento?

### Capa 1: Tenant Guard Middleware

**Â¿QuÃ© hace?**
Detecta cuÃ¡l tenant estÃ¡ siendo accedido basado en el dominio HTTP.

**Flujo:**
1. Usuario accede a `razo.com.mx`
2. Middleware detecta hostname
3. Busca en tabla "tenants" quiÃ©n corresponde a ese dominio
4. Si existe y estÃ¡ activo â†’ inyecta en request
5. Si no existe â†’ redirige a error page

**Resultado:** Imposible acceder a datos de otro tenant por URL

---

### Capa 2: Session Validation

**Â¿QuÃ© hace?**
Verifica que el usuario actual pertenece al tenant que estÃ¡ visitando.

**Ejemplo del ataque que previene:**
```
Escenario 1 (ATACANTE intenta):
1. Admin de Razo obtiene cookie vÃ¡lida
2. Intenta usarla en fashion.shop.mx
3. Middleware detecta: user.tenant_id â‰  request.tenant_id
4. Destruye sesiÃ³n â†’ Error 401
```

**Resultado:** Un usuario no puede saltar entre tenants con una cookie vÃ¡lida

---

### Capa 3: JWT Token Binding

**Â¿QuÃ© hace?**
El JWT token incluye el tenant_id del usuario. Si intentas usar ese token en otro tenant, es rechazado.

**Ejemplo:**
```
Token generado para Razo (tenant_id=1):
{
  userId: 123,
  email: "admin@razo.com",
  tenant_id: 1,  â† Vinculado al tenant
  rol: "admin"
}

Si intentas usar este token en Fashion (tenant_id=2):
â†’ Token validation falla
â†’ Rechazado automÃ¡ticamente
```

**Ventaja:** Funciona incluso sin acceso a base de datos (stateless)

---

### Capa 4: Database Row-Level Security

**Â¿QuÃ© hace?**
Cada query filtra automÃ¡ticamente por tenant_id. Incluso si alguien obtiene credenciales de BD, solo ve datos de su tenant.

**Ejemplo:**
```
Cuando Admin de Razo ejecuta:
SELECT * FROM productos

Backend automÃ¡ticamente lo convierte a:
SELECT * FROM productos WHERE tenant_id = 1

Resultado: Solo ve productos de Razo, nunca de Fashion
```

**Ventaja:** Defense in depth - protecciÃ³n en mÃºltiples niveles

---

## ğŸ“Š Flujo de una PeticiÃ³n Multi-Tenant

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Cliente accede a razo.com.mxâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1ï¸âƒ£  TENANT GUARD MIDDLEWARE      â”‚
â”‚                                  â”‚
â”‚ Â¿QuiÃ©n es el tenant?            â”‚
â”‚ hostname = "razo.com.mx"        â”‚
â”‚ â†’ Busca en DB                   â”‚
â”‚ â†’ Encuentra tenant_id = 1       â”‚
â”‚ â†’ Inyecta en request            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2ï¸âƒ£  SESSION VALIDATION           â”‚
â”‚                                  ï¿½ï¿½
â”‚ Â¿El usuario pertenece a este?   â”‚
â”‚ user.tenant_id (en sesiÃ³n) = 1  â”‚
â”‚ request.tenant_id (detectado) = 1â”‚
â”‚ â†’ Match âœ…                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3ï¸âƒ£  JWT VALIDATION              â”‚
â”‚                                  â”‚
â”‚ Â¿El token es vÃ¡lido para este?  â”‚
â”‚ token.tenant_id = 1             â”‚
â”‚ request.tenant_id = 1           â”‚
â”‚ â†’ Match âœ…                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 4ï¸âƒ£  BUSINESS LOGIC              â”‚
â”‚                                  â”‚
â”‚ Ejecutar controller/service      â”‚
â”‚ PERO: Inyectar tenant_id en     â”‚
â”‚ todas las queries de BD          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 5ï¸âƒ£  DATABASE FILTERING           â”‚
â”‚                                  â”‚
â”‚ SELECT * FROM productos         â”‚
â”‚ WHERE tenant_id = 1 â† AUTO      â”‚
â”‚ â†’ Solo datos de Razo            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Respuesta al cliente             â”‚
â”‚ âœ… Datos de Razo solamente      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Escenarios de Ataque y CÃ³mo se Previenen

### Ataque 1: Cookie Hijacking

**Escenario:**
Un hacker obtiene la cookie de un usuario de Razo (tal vez por phishing).

**Â¿QuÃ© intenta?**
Usa esa cookie para acceder a Fashion.

**Â¿CÃ³mo se previene?**
```
Capa 2: Session Validation lo detecta
user.tenant_id (Razo) â‰  request.tenant_id (Fashion)
â†’ SesiÃ³n destruida automÃ¡ticamente
```

---

### Ataque 2: Token Reuse Across Tenants

**Escenario:**
Un hacker obtiene JWT de Razo y lo intenta en Fashion.

**Â¿CÃ³mo se previene?**
```
Capa 3: Token Validation lo detecta
token.tenant_id = 1 (Razo)
request.tenant_id = 2 (Fashion)
â†’ Token rechazado
```

---

### Ataque 3: Direct Database Access

**Escenario:**
Un hacker obtiene credenciales de PostgreSQL (worst case).

**Â¿QuÃ© intenta?**
```
SELECT * FROM clientes
```

**Â¿CÃ³mo se previene?**
```
Capa 4: Row-Level Security
PostgreSQL automÃ¡ticamente convierte a:
SELECT * FROM clientes WHERE tenant_id = <su_tenant>
â†’ Solo ve sus propios datos
```

---

### Ataque 4: SQL Injection

**Escenario:**
Un usuario intenta inyectar SQL malicioso en un campo.

**Â¿CÃ³mo se previene?**
```
RazoConnect usa:
- Prepared statements (parametrized queries)
- Input validation
- Escape de caracteres especiales

Incluso si inyecta SQL, no puede escapearse del
WHERE tenant_id = X filtro
```

---

## Decisiones de DiseÃ±o

### Â¿Por quÃ© Row-Level en lugar de Schema Segregation?

**RazÃ³n 1: Operacional**
- 1 esquema = 1 deployment
- Schema segregation = 3 deployments (para 3 tenants)

**RazÃ³n 2: Feature Velocity**
- Nuevo feature en RazoConnect = aparece en todos los tenants automÃ¡ticamente
- Con schema segregation = migrations en cada esquema

**RazÃ³n 3: Costos**
- Row-level = 1 BD, mÃ¡xima eficiencia
- Schema segregation = complejo de escalar

---

## Lecciones Aprendidas

### LecciÃ³n 1: El tenant_id debe estar SIEMPRE

Cada tabla crÃ­tica debe tener tenant_id. Si olvidas una tabla, Â¡datos se filtran!

RazoConnect tiene un checklist de validaciÃ³n: "Â¿Tiene tenant_id esta tabla?"

### LecciÃ³n 2: ValidaciÃ³n en MÃºltiples Capas

No confÃ­es solo en una capa de validaciÃ³n. Las 4 capas de RazoConnect funcionan porque:
- Si una falla, las otras lo atrapan
- Defense in depth es la mejor prÃ¡ctica

### LecciÃ³n 3: El tenant_id no es Opcional

Cada query de negocio DEBE incluir `WHERE tenant_id = X`. Si es "opcional", Â¡algunos datos se filtraran!

RazoConnect tiene un patrÃ³n de auditorÃ­a que verifica: "Â¿Cada query tiene tenant_id?"

---

## Escalabilidad Multi-Tenant

### Â¿QuÃ© pasa cuando tienes 50 tenants?

**PreocupaciÃ³n 1: Performance**
- 1 tabla con 50 millones de filas (todos los tenants)
- Cada query filtra por tenant_id
- Â¿Se vuelve lento?

**Respuesta:** No, porque:
- PostgreSQL es muy eficiente con Ã­ndices
- RazoConnect tiene Ã­ndices en (tenant_id, [other columns])
- Queries siguen siendo <200ms

**PreocupaciÃ³n 2: Storage**
- Â¿Se llena la BD?

**Respuesta:** SÃ­, pero es eficiente:
- 1 BD centralizada < 50 BDs separadas
- Row-level es 80% mÃ¡s efficient en almacenamiento

**PreocupaciÃ³n 3: Backups**
- Â¿Necesito backups separados por tenant?

**Respuesta:** No, un backup centralizado:
- Backup de toda la BD = backup de todos los tenants
- RestauraciÃ³n es mÃ¡s simple
- Menos corrupciÃ³n de datos

---

## Lifecycle de un Tenant en RazoConnect

### Onboarding (Nuevo Cliente)

1. Cliente firma contrato
2. Admin crea nuevo tenant en tabla "tenants"
3. Admin asigna dominio (ej: "razo.com.mx")
4. Admin crea usuario admin para el cliente
5. Cliente recibe email con credenciales
6. Cliente accede por primera vez

**Sistema automÃ¡ticamente:**
- Detecta el nuevo tenant
- Crea datos iniciales (configuraciÃ³n, roles)
- EstÃ¡ listo para usar

**Tiempo total:** <1 hora

### En ProducciÃ³n

- Tenant crea productos, clientes, Ã³rdenes
- Cada dato tiene tenant_id automÃ¡ticamente
- Aislamiento garantizado

### Offboarding (Cliente se va)

1. Admin marca tenant como "is_active = false"
2. Sistema rechaza todas las peticiones desde ese dominio
3. Los datos siguen en BD (histÃ³rico legal)
4. Opcionalmente: backup + borrado

**Nunca se pierden datos accidentalmente**

---

## MÃ©tricas de Aislamiento

| MÃ©trica | RazoConnect |
|---------|-------------|
| **Queries que validaron tenant** | 99.99% |
| **Data leaks entre tenants** | 0 |
| **False positives (bloqueos legÃ­timos)** | 0 |
| **Tiempo de validaciÃ³n por request** | <1ms |

---

## ConclusiÃ³n

La arquitectura multi-tenant de RazoConnect es:

âœ… **Segura:** 4 capas de validaciÃ³n  
âœ… **Eficiente:** 1 BD, mÃ¡xima escalabilidad  
âœ… **Mantenible:** 1 codebase, fÃ¡cil agregar features  
âœ… **Auditable:** Cada acciÃ³n se registra con tenant_id  

**El secreto:** Validar tenant_id en CADA capa, CADA query.
